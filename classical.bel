% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
;


--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B

  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Peirce's Law
  | PL: (cnd (A ⊃ ⊥) → cnd A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (A ⊃ ⊥))] =
[ ⊢ PL (\u. ∨Ir (
          ⊃I (\v.
            ⊃E u (∨Il v)
          )
))
  ] 
;





hole : type.


% Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | taut : tm
  | abort : tm → tm 

  | throw : stack → tm → tm 

  | letcc : (stack → tm) → tm


% Stack with holes
and stack : type =
  | s_lam : hole → tm → stack → stack % app _ N k
  | s_app : tm → hole → stack → stack % app M _
  
  | s_pair_l : hole → tm → stack → stack
  | s_pair_r : tm → hole → stack → stack
  | s_fst : hole → stack → stack
  | s_snd : hole → stack → stack

  | s_inl : hole → stack → stack
  | s_inr : hole → stack → stack
  | s_cse : hole → (tm → tm) → (tm → tm) → stack → stack

  | s_abort : hole → stack → stack

  | halt : stack % no need for k since its end of program


;


% Use proof terms
LF pt_true : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃I : ({x : tm} pt_true x A → pt_true (M x) B)  → pt_true (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃E : pt_true M (A ⊃ B) → pt_true N A → pt_true (app M N) B

  | ∧I : pt_true M A → pt_true N B → pt_true (pair M N) (A ∧ B)
  | ∧El : pt_true M (A ∧ B) → pt_true (fst M) A
  | ∧Er : pt_true M (A ∧ B) → pt_true (snd M) B

  | ∨Il : pt_true M A → pt_true (inl M) (A ∨ B)
  | ∨Ir : pt_true M B → pt_true (inr M) (A ∨ B)
  | ∨E  : pt_true M (A ∨ B)
        → ({x : tm} pt_true x A → pt_true (Nl x) C)
        → ({y : tm} pt_true y B → pt_true (Nr y) C)   
        → pt_true (cse M (\x. Nl x) (\y. Nr y)) C

  | ⊤I : pt_true taut ⊤

  | ⊥E : pt_true M ⊥ → pt_true (abort M) C

  | throw_app : pt_false k A → pt_true M A → pt_true (throw k M) ⊥

  | PL: ({a : stack} pt_false a A → pt_true M A) → pt_true (letcc (\a. M)) A

and pt_false: stack → o → type = 
  | ⊥FI : pt_false k M → pt_false (s_abort _ k) ⊥

  | ⊃FI : pt_true N A → pt_false k B → pt_false (s_lam _ N k) (A ⊃ B)
  | ⊃FE : pt_true M (A ⊃ B) → pt_false k B → pt_false (s_app M _ k) A

  | ∧FEl : pt_true N B → pt_false k (A ∧ B) → pt_false (s_pair_l _ N k) A
  | ∧FEr : pt_true M A → pt_false k (A ∧ B) → pt_false (s_pair_r M _ k) B

  | ∧FIl : pt_false k A → pt_false (s_fst _ k) (A ∧ B)
  | ∧FIr : pt_false k B → pt_false (s_snd _ k) (A ∧ B)

  | ∨FEl : pt_false k (A ∨ B) → pt_false (s_inl _ k) A
  | ∨FEr : pt_false k (A ∨ B) → pt_false (s_inr _ k) B

  | ∨FI  :({x : tm} pt_true x A → pt_true M C)
        → ({y : tm} pt_true y B → pt_true N C)   
        → pt_false k C
        → pt_false (s_cse _ (\x. M) (\y. N) k) (A ∨ B)
;






LF joint : type =
  | config: tm → stack → joint
;


% With both contexts
LF pt_conf : joint → o → type = 
  | joined : pt_true M A → pt_false k A → pt_conf (config M k) A
;


% Values 
LF value : tm → type =
  | value_taut : value taut
  | value_lam : value (lam (\x. M))
  | value_pair : value M → value N → value (pair M N)
  | value_inl : value M → value (inl M)
  | value_inr : value M → value (inr M)
  ;


% Terminal
LF term : tm → stack → type =
  | term_taut : term taut halt
  | term_lam : term (lam (\x. M)) halt
  | term_pair : value M → value N → term (pair M N) halt
  | term_inl : value M → term (inl M) halt
  | term_inr : value M → term (inr M) halt
;


% Small step
LF step : joint → joint → type = 
  | step_abort : (step (config (abort M) k) (config M (s_abort _ k)))

  | step_throw : (step (config (throw k' M') k) (config M' k'))

  | step_lam : (step (config (app M N) k) (config M (s_lam _ N k)))

  | step_app : (step (config (lam (\x. M')) (s_lam _ N k)) (config N (s_app (lam (\x. M')) _ k)))

  | step_app_lam : value v → (step (config v (s_app (lam (\x. (M' x))) _ k)) (config (M' v) k))

  | step_pair_l : (step (config (pair M N) k) (config M (s_pair_l _ N k)))

  | step_pair_r : value v → (step (config v (s_pair_l _ N k)) (config N (s_pair_r v _ k)))

  | step_pair_comp : value v → value w → (step (config w (s_pair_r v _ k)) (config (pair v w) k))

  | step_fst : (step (config (fst M) k) (config M (s_fst _ k)))
  | step_snd : (step (config (snd M) k) (config M (s_snd _ k)))

  | step_fst_pair : value v → value w → (step (config (pair v w) (s_fst _ k)) (config v k))
  | step_snd_pair : value v → value w → (step (config (pair v w) (s_snd _ k)) (config w k))

  | step_inl : (step (config (inl M) k) (config M (s_inl _ k)))
  | step_inr : (step (config (inr M) k) (config M (s_inr _ k)))

  | step_inl_comp : value v → (step (config v (s_inl _ k)) (config (inl v) k))
  | step_inr_comp : value v → (step (config v (s_inr _ k)) (config (inr v) k))

  | step_cse : (step (config (cse L (\x. M) (\y. N)) k) (config L (s_cse _ (\x. M) (\y. N) k)))

  | step_cse_inl : value v → (step (config (inl v) (s_cse _ (\x. (M x)) (\y. (N y)) k)) (config (M v) k))
  | step_cse_inr : value v → (step (config (inr v) (s_cse _ (\x. (M x)) (\y. (N y)) k)) (config (N v) k))
  
  | step_let_cc : (step (config (letcc (\a. (M a))) k) (config (M k) k))

;


LF exist : o → type =
    | val_bot : exist ⊥
    | val_top : exist ⊤
    | val_lam_t : exist (A ⊃ B)
    | val_and : exist (A ∧ B)
    | val_or : exist (A ∨ B)
  ;

% Preservation
rec pres : [ ⊢ exist P'] → [ ⊢ pt_conf (config M k) P] → [ ⊢ step (config M k) (config M' k') ] → [ ⊢ pt_conf (config M' k') P']  = 
/ total s (pres P' M k P M' k' f p s)/
fn f ⇒ fn p ⇒ fn s ⇒ case s of
  | [ ⊢ step_abort] ⇒	
    let [ ⊢ val_bot ] = f in
    let [ ⊢ joined (⊥E D1) (D2)] = p in 
      [ ⊢ joined D1 (⊥FI D2)]
      
  | [ ⊢ step_lam] ⇒	?
    % let [ ⊢ joined (⊃E D1 D2) (D3)] = p in 
    % let [ ⊢ val_lam_f (⊃FI D2 D3)] = f in
    %   [ ⊢ joined D1 (⊃FI D2 D3)]
      
  | [ ⊢ step_app] ⇒	?
      
  | [ ⊢ step_app_lam V1] ⇒	?
      
  | [ ⊢ step_pair_l] ⇒	?
      
  | [ ⊢ step_pair_r V1] ⇒	?
      
  | [ ⊢ step_pair_comp V1 V2] ⇒	?
      
  | [ ⊢ step_fst] ⇒	?
      
  | [ ⊢ step_snd] ⇒	?
      
  | [ ⊢ step_fst_pair V1 V2] ⇒	?
      
  | [ ⊢ step_snd_pair V1 V2] ⇒	?
      
  | [ ⊢ step_inl] ⇒	?
      
  | [ ⊢ step_inr] ⇒	?
      
  | [ ⊢ step_inl_comp V] ⇒	?
      
  | [ ⊢ step_inr_comp V] ⇒	?
      
  | [ ⊢ step_cse] ⇒	?
      
  | [ ⊢ step_cse_inl V] ⇒	?
      
  | [ ⊢ step_cse_inr V] ⇒	?
      
  | [ ⊢ step_let_cc] ⇒	?
      
  | [ ⊢ step_throw] ⇒	?
;


% Step or terminal
step_or_term : tm → stack → type.
step_to : (step (config M k) (config M' k')) -> step_or_term M k.
terminate : (term M k) -> step_or_term M k.


% Progress 
rec prog : [ ⊢ pt_conf (config M k) P] → [ ⊢ step_or_term M k] = 
/ total p (prog M k P p)/
fn p ⇒ case p of
  | [ ⊢ joined D1 D2] ⇒ 
    (case [ ⊢ D1]  of
        | [ ⊢ ⊥E D3] ⇒ [ ⊢ step_to (step_abort)]
    )
;
%   | [ ⊢ ⊥E D1] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_abort EV)]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1]
%       | [ ⊢ val (value_lam)] ⇒ impossible [ ⊢ D1]
%     )

%   | [ ⊢ ⊃Ip (\x. \d. D)] ⇒  [ ⊢ val value_lam]
%   | [ ⊢ ⊃Ep D1 D2] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_app_l EV)]
%       | [ ⊢ val value_lam] ⇒ 
%         (case  prog [ |- D2]   of
%           | [ |- step_to EV] => [ |- step_to (step_app_r value_lam EV)]
%           | [ |- val VL] => [ |- step_to (step_app_lam VL)]
%        )
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1] 
%     )

%   | [ ⊢ ∧Ip D1 D2] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_pair_l EV)]
%       | [ ⊢ val VL1] ⇒ 
%         (case  prog [ |- D2]   of
%           | [ |- step_to EV] => [ |- step_to (step_pair_r VL1 EV)]
%           | [ |- val VL2] => [ |- val (value_pair VL1 VL2)]
%        )
%     )

%   | [ ⊢ ∧Elp D] ⇒		
%     (case prog [ ⊢ D]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_fst EV)]
%       | [ ⊢ val (value_pair _ _)] ⇒ [ ⊢ step_to step_fst_pair]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D] 
%     )

%   | [ ⊢ ∧Erp D] ⇒			
%     (case prog [ ⊢ D]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_snd EV)]
%       | [ ⊢ val (value_pair _ _)] ⇒ [ ⊢ step_to step_snd_pair]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D] 
%     )

%   | [ ⊢ ∨Ilp D] ⇒		
%     (case prog [ ⊢ D]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_inl EV)]
%       | [ ⊢ val V] ⇒ [ ⊢ val (value_inl V)] 
%     )
  
%   | [ ⊢ ∨Irp D] ⇒		
%     (case prog [ ⊢ D]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_inr EV)]
%       | [ ⊢ val V] ⇒ [ ⊢ val (value_inr V)] 
%     )

%   | [ ⊢ ∨Ep D1 (\a. \d1. D2) (\b. \d2. D3)] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_cse EV)]
%       | [ ⊢ val (value_inl V)] ⇒ [ ⊢ step_to (step_inl_cse)]
%       | [ ⊢ val (value_inr V)] ⇒ [ ⊢ step_to (step_inr_cse)]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D1] 
%     )


%   | [ ⊢ ¬Ip (\u. \v. D)] ⇒  [ ⊢ val value_intro_n]

%   | [ ⊢ ¬Ep D1 D2] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_abort_n_l EV)]
%       | [ ⊢ val value_intro_n] ⇒ 
%         (case  prog [ |- D2]   of
%           | [ |- step_to EV] => [ |- step_to (step_abort_n_r value_intro_n EV)]
%           | [ |- val VL] => [ |- step_to (step_neg VL)]
%        )
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1] 
%     )

%   | [ ⊢ ∀Ip (\d. D)] ⇒	[ ⊢ val value_lam_f]
%   | [ ⊢ ∀Ep T1 D1] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_app_f EV)]
%       | [ ⊢ val value_lam_f] ⇒ [ ⊢ step_to (step_all)]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1] 
%     )

%   | [ ⊢ ∃Ip T1 D1] ⇒		
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_pair_f EV)]
%       | [ ⊢ val V] ⇒ [ ⊢ val (value_pair_f V)] 
%     )

%   | [ ⊢ ∃Ep D1 (\u. \v. \w. D2)] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_let_val_f EV)]
%       | [ ⊢ val (value_pair_f V)] ⇒ [ ⊢ step_to (step_exist)]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%     )

%   | [ ⊢ PLp D1] ⇒	
%     (case prog [ ⊢ D1]  of
%       | [ ⊢ step_to EV] ⇒ [ ⊢ step_to (step_callcc EV)]
%       % TODO
%       | [ ⊢ val value_lam] ⇒ [ ⊢ ?]
%       | [ ⊢ val (value_pair_f _)] ⇒ impossible [ ⊢ D1]
%       | [ ⊢ val value_taut] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_intro_n] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_pair _ _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inl _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val (value_inr _)] ⇒ impossible [ ⊢ D1] 
%       | [ ⊢ val value_lam_f] ⇒ impossible [ ⊢ D1] 
%     )

% ;




