% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
  | ¬  : o → o
  | ∀  : (i → o) → o
  | ∃  : (i → o) → o
;


--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B
  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C
  | ⊤I : cnd ⊤

  % Negation
  | ¬I : ({p:o} cnd A → cnd p)
	 → cnd (¬ A)
	       
  | ¬E : cnd (¬ A) → cnd A
	 → cnd C
	       

  % First Order Logic
  | ∀I : ({a:i} cnd (A a)) 
	 → cnd (∀ (\x. A x))

  | ∀E : {T:i} cnd (∀ A) 
	 → cnd (A T)       

  | ∃I : {T:i} cnd (A T)           
	 → cnd (∃ A)

  | ∃E : cnd (∃ A)
	 → ({a:i} cnd (A a) → cnd C)
	 → cnd C

  % Peirce's Law
  | PL: cnd ((A ⊃ B) ⊃ A) → cnd A

;


schema nctx = cnd A ;


% Alternate Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | nil : tm

  | app_p : tm → i → tm
  | lam_p : (i → tm) → tm
  
  | pair_p : tm → i → tm
  | let_val_p : (i -> tm → tm) → tm → tm % TODO check if correct

  % TODO: add negation proof term?

  % TODO: add continuation for Peirces Law
  % | cont : ?
;



% Use proof terms
LF pt : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃Ip : ({x : tm} pt x A → pt (M x) B)  → pt (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃Ep : pt M (A ⊃ B) → pt N A → pt (app M N) B

  % TODO finish the rest

  | ∧Ip : pt M A → pt N B → pt (pair M N) (A ∧ B)
  | ∧Elp : pt M (A ∧ B) → pt (fst M) A
  | ∧Erp : pt M (A ∧ B) → pt (snd M) B

  | ∨Ilp : pt M A → pt (inl M) (A ∨ B)
  | ∨Irp : pt M B → pt (inr M) (A ∨ B)
  | ∨Ep  : pt M (A ∨ B)
        → ({x : tm} pt x A → pt (Nl x) C)
        → ({y : tm} pt y B → pt (Nr y) C)   
        → pt (cse M (\x. Nl x) (\y. Nl y)) C

  | ⊤Ip : pt nil ⊤

  % Negation TODO
  % | ¬Ip : ({p:o} cnd A → cnd p)
	%  → cnd (¬ A)
	       
  % | ¬Ep : cnd (¬ A) → cnd A
	%  → cnd C
	       

  % First Order Logic
  | ∀Ip : ({a:i} pt (M a) (A a)) 
	 → pt (lam_p (\a. M a)) (∀ (\x. A x))

  | ∀Ep : {T:i} pt M (∀ A) 
	 → pt (app_p M T) (A T)       

  | ∃Ip : {T:i} pt (M) (A T)           
	 → pt (pair_p M T) (∃ A)

  | ∃Ep : pt M (∃ A)
	 → ({a:i, u:tm} pt u (A a) → pt (N u a) C)
	 → pt (let_val_p (\a.\u. N u a) M) C

  % Peirce's Law TODO
  % | PLp: cnd ((A ⊃ B) ⊃ A) → cnd A

;