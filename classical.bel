% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
  | ¬  : o → o
  | ∀  : (i → o) → o
  | ∃  : (i → o) → o
;


--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B
  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Negation
  | ¬I : ({p:o} cnd A → cnd p)
	 → cnd (¬ A)
	       
  | ¬E : cnd (¬ A) → cnd A
	 → cnd C
	       

  % First Order Logic
  | ∀I : ({a:i} cnd (A a)) 
	 → cnd (∀ (\x. A x))

  | ∀E : {T:i} cnd (∀ A) 
	 → cnd (A T)       

  | ∃I : {T:i} cnd (A T)           
	 → cnd (∃ A)

  | ∃E : cnd (∃ A)
	 → ({a:i} cnd (A a) → cnd C)
	 → cnd C

  % Peirce's Law
  | PL: cnd ((A ⊃ B) ⊃ A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (¬ A))] =
[ ⊢ PL (⊃I \u. 
          (⊥E 
            (⊃E 
              (⊃I \v. 
                (⊃E u (∨Ir v))
              )
              (¬I \p. \w. ⊥E 
                (⊃E u (∨Il w))
              )
            )
          )
        )
  ] 
;



% Alternate Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | nil : tm
  | abort : tm → tm

  % First Order Logic
  | app_f : tm → i → tm
  | lam_f : (i → tm) → tm
  
  | pair_f : tm → i → tm
  | let_val_f : tm → (i -> tm → tm) → tm 

  % Negation
  | abort_n : tm → tm → tm
  | intro_n : (o → tm → tm) → tm

  % Peirces Law proof term
  % call with current continuation: cc
  | cc : tm → tm
;



% Use proof terms
LF pt : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃Ip : ({x : tm} pt x A → pt (M x) B)  → pt (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃Ep : pt M (A ⊃ B) → pt N A → pt (app M N) B

  | ∧Ip : pt M A → pt N B → pt (pair M N) (A ∧ B)
  | ∧Elp : pt M (A ∧ B) → pt (fst M) A
  | ∧Erp : pt M (A ∧ B) → pt (snd M) B

  | ∨Ilp : pt M A → pt (inl M) (A ∨ B)
  | ∨Irp : pt M B → pt (inr M) (A ∨ B)
  | ∨Ep  : pt M (A ∨ B)
        → ({x : tm} pt x A → pt (Nl x) C)
        → ({y : tm} pt y B → pt (Nr y) C)   
        → pt (cse M (\x. Nl x) (\y. Nr y)) C

  | ⊤Ip : pt nil ⊤

  | ⊥E : pt M ⊥ → pt (abort M) C

  % Negation
  | ¬Ip : ({x : tm}{p:o} pt x A → pt (M p x) p)
	 → pt (intro_n (\p. \x. M p x)) (¬ A)
	       
  | ¬Ep : pt M (¬ A) → pt N A
	 → pt (abort_n M N) C
	       
  % First Order Logic
  | ∀Ip : ({a:i} pt (M a) (A a)) 
	 → pt (lam_f (\a. M a)) (∀ (\x. A x))

  | ∀Ep : {T:i} pt M (∀ A) 
	 → pt (app_f M T) (A T)       

  | ∃Ip : {T:i} pt (M) (A T)           
	 → pt (pair_f M T) (∃ A)

  | ∃Ep : pt M (∃ A)
	 → ({a:i}{u:tm} pt u (A a) → pt (N u a) C)
	 → pt (let_val_f M (\a.\u. N u a)) C

  % Peirce's Law 
  | PLp: pt M ((A ⊃ B) ⊃ A) → pt (cc M) A

;

% TODO prove preservation and progress
% Examples:
% https://github.com/Beluga-lang/Beluga/blob/master/examples/mini-ml/tps.bel
% https://github.com/Beluga-lang/Beluga/blob/master/examples/small-step/lam.bel


%TODO
% Values (not sure what exactly it is yet)
LF value : tm → type =
  | value_nil : value nil
  | value_lam : value (lam (\x. M x))
  | value_intro_n : ?
  | value_lam_f : 
  ;



%TODO
% Step (reduction)
LF step : tm → tm → type = 
  % Congruence Rules
  % They done involve any simplifications, they usually only update propositions
  | step_app_l : (step A1 A2) → (step (app A1 B) (app A2 B))
  | step_app_r : (value A) → (step B1 B2) → (step (app A B1) (app A B2))

  % This doesnt work
  % In this context lambda is a function, so it cant be stepped through until the value of x is known
  % So lam is a value instead
  % Beluga checks this automatically, if you uncomment this line it gives and error
  % | step_lam : (step M1 M2) → (step (lam (\x. M1 x)) (lam (\x. M2 x)))

  | step_pair_l : ?
  | step_pair_r : ?

  | step_fst : ?
  | step_snd : ?

  | step_inl : ?
  | step_inr : ?

  % For case, the functions cant be stepped, but the other term can be
  
  % Correctly Doesnt work (not sure if we need value for it or not) TODO
  % | step_cse_l : step Nl1 Nl2 → step (cse M (\x. Nl1 x) (\y. Nr y)) (cse M (\x. Nl2 x) (\y. Nr y)) 

  % works
  | step_cse : step M1 M2 → step (cse M1 (\x. Nl x) (\y. Nr y)) (cse M2 (\x. Nl x) (\y. Nr y))

  | step_abort : ?

  % First Order Logic
  | step_app_f : ?
  
  | step_pair_f : ?

  % TODO might also need a value
  | step_let_val_f : ?

  % Negation
  | abort_n : ?

  % Peirces Law proof term
  % call with current continuation: cc
  | step_cc : ?
;





% Preservation

% Cases TODO
%   ALL CONGRUENCE RULES
%
%   app (lam (\x. M) N) = [N/x] M 
% 
%   fst (A B) = A
%   snd (A B) = B
% 
%   cse M (inl N) (...) = N
%   cse M (...) (inr N) = N
% 
%   abort_n ((intro_n (\p. \x. M p x))) N = [N/x][C/p]N (C is the proposition)
%   
%   app_f (lam_f (\a. M a)) t = [t/a] M
%   
%   let_val_f (pair_f M T) (\a.\u. N u a) = [M/u, T/a] N
%   
%   cc (lam (\x. M))) = M ?





% Progress
