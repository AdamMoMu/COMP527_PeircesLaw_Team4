% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
;


--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B

  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Peirce's Law
  | PL: (cnd (A ⊃ ⊥) → cnd A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (A ⊃ ⊥))] =
[ ⊢ PL (\u. ∨Ir (
          ⊃I (\v.
            ⊃E u (∨Il v)
          )
))
  ] 
;





hole : type.


% Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | taut : tm
  | abort : tm → tm 

  | throw : stack → tm → tm 

  | letcc : (stack → tm) → tm


% Stack with holes
and stack : type =
  | s_lam : hole → tm → stack → stack % app _ N k
  | s_app : tm → hole → stack → stack % app M _
  
  | s_pair_l : hole → tm → stack → stack
  | s_pair_r : tm → hole → stack → stack
  | s_fst : hole → stack → stack
  | s_snd : hole → stack → stack

  | s_inl : hole → stack → stack
  | s_inr : hole → stack → stack
  | s_cse : hole → (tm → tm) → (tm → tm) → stack → stack

  | s_abort : hole → stack → stack

  | halt : stack % no need for k since its end of program


;


% Use proof terms
LF pt_true : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃I : ({x : tm} pt_true x A → pt_true (M x) B)  → pt_true (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃E : pt_true M (A ⊃ B) → pt_true N A → pt_true (app M N) B

  | ∧I : pt_true M A → pt_true N B → pt_true (pair M N) (A ∧ B)
  | ∧El : pt_true M (A ∧ B) → pt_true (fst M) A
  | ∧Er : pt_true M (A ∧ B) → pt_true (snd M) B

  | ∨Il : pt_true M A → pt_true (inl M) (A ∨ B)
  | ∨Ir : pt_true M B → pt_true (inr M) (A ∨ B)
  | ∨E  : pt_true M (A ∨ B)
        → ({x : tm} pt_true x A → pt_true (Nl x) C)
        → ({y : tm} pt_true y B → pt_true (Nr y) C)   
        → pt_true (cse M (\x. Nl x) (\y. Nr y)) C

  | ⊤I : pt_true taut ⊤

  | ⊥E : pt_true M ⊥ → pt_true (abort M) C

  | throw_app : pt_false k A → pt_true M A → pt_true (throw k M) ⊥

  | PL: ({a : stack} pt_false a A → pt_true M A) → pt_true (letcc (\a. M)) A

and pt_false: stack → o → type = 
  | ⊥FI : pt_false k M → pt_false (s_abort _ k) ⊥

  | ⊃FI : pt_true N A → pt_false k B → pt_false (s_lam _ N k) (A ⊃ B)
  | ⊃FE : pt_true M (A ⊃ B) → pt_false k B → pt_false (s_app M _ k) A

  | ∧FEl : pt_true N B → pt_false k (A ∧ B) → pt_false (s_pair_l _ N k) A
  | ∧FEr : pt_true M A → pt_false k (A ∧ B) → pt_false (s_pair_r M _ k) B

  | ∧FIl : pt_false k A → pt_false (s_fst _ k) (A ∧ B)
  | ∧FIr : pt_false k B → pt_false (s_snd _ k) (A ∧ B)

  | ∨FEl : pt_false k (A ∨ B) → pt_false (s_inl _ k) A
  | ∨FEr : pt_false k (A ∨ B) → pt_false (s_inr _ k) B

  | ∨FI  :({x : tm} pt_true x A → pt_true M C)
        → ({y : tm} pt_true y B → pt_true N C)   
        → pt_false k C
        → pt_false (s_cse _ (\x. M) (\y. N) k) (A ∨ B)
;






LF joint : type =
  | config: tm → stack → joint
;


% With both contexts
LF pt_conf : joint → o → type = 
  | joined : pt_true M A → pt_false k A → pt_conf (config M k) A
;


% Values 
LF value : tm → type =
  | value_taut : value taut
  | value_lam : value (lam (\x. M))
  | value_pair : value M → value N → value (pair M N)
  | value_inl : value M → value (inl M)
  | value_inr : value M → value (inr M)
  ;


% Terminal
LF term : joint → type =
  | term_taut : term (config taut halt)
  | term_lam : term (config (lam (\x. M)) halt)
  | term_pair : value M → value N → term (config (pair M N) halt)
  | term_inl : value M → term (config (inl M) halt)
  | term_inr : value M → term (config (inr M) halt)
;


% Small step
LF step : joint → joint → type = 
  | step_abort : (step (config (abort M) k) (config M (s_abort _ k)))

  | step_throw : (step (config (throw k' M') k) (config M' k'))

  | step_lam : (step (config (app M N) k) (config M (s_lam _ N k)))

  | step_app : (step (config (lam (\x. M')) (s_lam _ N k)) (config N (s_app (lam (\x. M')) _ k)))

  | step_app_lam : value v → (step (config v (s_app (lam (\x. (M' x))) _ k)) (config (M' v) k))

  | step_pair_l : (step (config (pair M N) k) (config M (s_pair_l _ N k)))

  | step_pair_r : value v → (step (config v (s_pair_l _ N k)) (config N (s_pair_r v _ k)))

  | step_pair_comp : value v → value w → (step (config w (s_pair_r v _ k)) (config (pair v w) k))

  | step_fst : (step (config (fst M) k) (config M (s_fst _ k)))
  | step_snd : (step (config (snd M) k) (config M (s_snd _ k)))

  | step_fst_pair : value v → value w → (step (config (pair v w) (s_fst _ k)) (config v k))
  | step_snd_pair : value v → value w → (step (config (pair v w) (s_snd _ k)) (config w k))

  | step_inl : (step (config (inl M) k) (config M (s_inl _ k)))
  | step_inr : (step (config (inr M) k) (config M (s_inr _ k)))

  | step_inl_comp : value v → (step (config v (s_inl _ k)) (config (inl v) k))
  | step_inr_comp : value v → (step (config v (s_inr _ k)) (config (inr v) k))

  | step_cse : (step (config (cse L (\x. M) (\y. N)) k) (config L (s_cse _ (\x. M) (\y. N) k)))

  | step_cse_inl : value v → (step (config (inl v) (s_cse _ (\x. (M x)) (\y. (N y)) k)) (config (M v) k))
  | step_cse_inr : value v → (step (config (inr v) (s_cse _ (\x. (M x)) (\y. (N y)) k)) (config (N v) k))
  
  | step_let_cc : (step (config (letcc (\a. (M a))) k) (config (M k) k))

;




LF tm_sub: tm → tm → type =
  | sub_app_lam : value N → tm_sub (app (lam (\x. M x)) N) (M N)
  
  | sub_fst_pair : tm_sub (fst (pair M N)) M
  | sub_snd_pair : tm_sub (snd (pair M N)) N
  
  | sub_inl_cse : tm_sub (cse (inl M) (\x. Nl x) (\y. Nr y)) (Nl M)
  | sub_inr_cse : tm_sub (cse (inr M) (\x. Nl x) (\y. Nr y)) (Nr M)

;


rec sub_lemma : [ ⊢ pt_true M P] → [ ⊢ tm_sub M M'] → [ ⊢ pt_true M' P] = 
/ total s (sub_lemma M P M' p s)/
fn p ⇒ fn s ⇒ case s of
  | [ ⊢ sub_app_lam V] ⇒	
    let [ ⊢ ⊃E (⊃I (\v. \u. D1)) D2] = p in
      [ ⊢ D1[_,D2]]

  | [ ⊢ sub_fst_pair] ⇒	
    let [ ⊢ ∧El (∧I D1 D2)] = p in
      [ ⊢ D1]

  | [ ⊢ sub_snd_pair] ⇒	
    let [ ⊢ ∧Er (∧I D1 D2)] = p in
      [ ⊢ D2]

  | [ ⊢ sub_inl_cse] ⇒	
    let [ ⊢ ∨E (∨Il D1) (\u. \v. D2) (\u. \v. D3)] = p in
      [ ⊢ D2[_,D1]]

  | [ ⊢ sub_inr_cse] ⇒	
    let [ ⊢ ∨E (∨Ir D1) (\u. \v. D2) (\u. \v. D3)] = p in
      [ ⊢ D3[_,D1]]
;



inductive Result : {M : [ ⊢ tm]}{k : [ ⊢ stack]} → ctype =
| Res : {P : [ ⊢ o]} 
      → [ ⊢ pt_true M P]
      → [ ⊢ pt_false k P]
      → Result [ ⊢ M] [ ⊢ k]
;




% Preservation
rec pres :  [ ⊢ pt_conf (config M k) P] → [ ⊢ step (config M k) (config M' k') ] → Result [ ⊢ M'] [ ⊢ k'] = 
/ total s (pres M k P M' k' p s)/
fn p ⇒ fn s ⇒ case s of
  | [ ⊢ step_abort] ⇒	
    let [ ⊢ joined (⊥E D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (⊥FI D2)]
      
  | [ ⊢ step_lam] ⇒	
    let [ ⊢ joined (⊃E D1 D2) (D3)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (⊃FI D2 D3)]
      
  | [ ⊢ step_app] ⇒	
    let [ ⊢ joined D1 (⊃FI D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ D2] [ ⊢ (⊃FE D1 D3)]
      
  | [ ⊢ step_app_lam V1] ⇒	
    let [ ⊢ joined D1 (⊃FE D2 D3)] = p in 
    let [ ⊢ D4] = (sub_lemma [ ⊢ ⊃E D2 D1] [ ⊢ sub_app_lam V1]) in
      Res [ ⊢ _] [ ⊢ D4] [ ⊢ D3]
      
  | [ ⊢ step_pair_l] ⇒	
    let [ ⊢ joined (∧I D1 D2) (D3)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∧FEl D2 D3)]
      
  | [ ⊢ step_pair_r V1] ⇒	
    let [ ⊢ joined D1 (∧FEl D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ D2] [ ⊢ (∧FEr D1 D3)]
      
  | [ ⊢ step_pair_comp V1 V2] ⇒	
    let [ ⊢ joined D1 (∧FEr D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ ∧I D2 D1] [ ⊢ D3]
      
  | [ ⊢ step_fst] ⇒	
    let [ ⊢ joined (∧El D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∧FIl D2)]
      
  | [ ⊢ step_snd] ⇒	
    let [ ⊢ joined (∧Er D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∧FIr D2)]
      
  | [ ⊢ step_fst_pair V1 V2] ⇒	
    let [ ⊢ joined (∧I D1 D2) (∧FIl D3)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ D3]
      
  | [ ⊢ step_snd_pair V1 V2] ⇒	
    let [ ⊢ joined (∧I D1 D2) (∧FIr D3)] = p in 
      Res [ ⊢ _] [ ⊢ D2] [ ⊢ D3]
      
  | [ ⊢ step_inl] ⇒	
    let [ ⊢ joined (∨Il D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∨FEl D2)]
      
  | [ ⊢ step_inr] ⇒	
    let [ ⊢ joined (∨Ir D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∨FEr D2)]
      
  | [ ⊢ step_inl_comp V] ⇒	
    let [ ⊢ joined D1 (∨FEl D2)] = p in 
      Res [ ⊢ _] [ ⊢ (∨Il D1)] [ ⊢ D2]
      
  | [ ⊢ step_inr_comp V] ⇒	
    let [ ⊢ joined D1 (∨FEr D2)] = p in 
      Res [ ⊢ _] [ ⊢ (∨Ir D1)] [ ⊢ D2]
      
  | [ ⊢ step_cse] ⇒	
    let [ ⊢ joined (∨E D1 (\x. \d. D2) (\y. \d. D3)) D4] = p in 
      Res [ ⊢ _] [ ⊢ D1] [ ⊢ (∨FI (\x. \d. D2) (\y. \d. D3) D4)]
      
  | [ ⊢ step_cse_inl V] ⇒	
    let [ ⊢ joined D1 (∨FI (\x. \d. D2) (\y. \d. D3) D4)] = p in 
    let [ ⊢ D5] = (sub_lemma [ ⊢ (∨E D1 (\x. \d. D2) (\y. \d. D3))] [ ⊢ sub_inl_cse]) in
      Res [ ⊢ _] [ ⊢ D5] [ ⊢ D4]
      
  | [ ⊢ step_cse_inr V] ⇒	
    let [ ⊢ joined D1 (∨FI (\x. \d. D2) (\y. \d. D3) D4)] = p in 
    let [ ⊢ D5] = (sub_lemma [ ⊢ (∨E D1 (\x. \d. D2) (\y. \d. D3))] [ ⊢ sub_inr_cse]) in
      Res [ ⊢ _] [ ⊢ D5] [ ⊢ D4]
      
  | [ ⊢ step_throw] ⇒
    let [ ⊢ joined (throw_app D1 D2) D3] = p in 
      Res [ ⊢ _] [ ⊢ D2] [ ⊢ D1]
      
  | [ ⊢ step_let_cc] ⇒
    let [ ⊢ joined (PL (\a. \d. D1)) D2] = p in 
      Res [ ⊢ _] [ ⊢ D1[_,D2]] [ ⊢ D2]
;


% Step or terminal
LF step_or_terminate : type =
 | step_to : (step C C') -> step_or_terminate
 | terminate : (term C) -> step_or_terminate
;


inductive Result_prog : ctype =
| Res_step : {S : [ ⊢ step_or_terminate]} 
      → {M : [ ⊢ tm]} 
      → {k : [ ⊢ stack]} 
      → {M' : [ ⊢ tm]} 
      → {k' : [ ⊢ stack]} 
      → [ ⊢ step (config M k) (config M' k')]
      → Result_prog

| Res_term : {S : [ ⊢ step_or_terminate]} 
      → {M : [ ⊢ tm]} 
      → {k : [ ⊢ stack]} 
      → [ ⊢ term (config M k)]
      → Result_prog 
;

% Progress 
rec prog : [ ⊢ joint] → Result_prog = 
/ total c (prog c)/
fn c ⇒ case c of
  | [ ⊢ config taut halt] ⇒ Res_term [ ⊢ _] [ ⊢ taut] [ ⊢ halt] [ ⊢ term_taut]

  | [ ⊢ config (abort M) k] ⇒ Res_step [ ⊢ _] [ ⊢ taut] [ ⊢ halt] [ ⊢ term_taut]

  | [ ⊢ config (lam (\x. M)) halt] ⇒ ?
  | [ ⊢ config (lam (\x. M)) halt] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_lam _ N k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_app (lam (\y. N)) _ k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_pair_l _ N k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_pair_r N _ k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_inl _ k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_inr _ k)] ⇒ ?

  | [ ⊢ config (app M N) k] ⇒ ?

  | [ ⊢ config (pair M N) k] ⇒ ?
  | [ ⊢ config (pair v w) halt] ⇒ ?
  | [ ⊢ config (pair v w) (s_app (lam (\y. N)) _ k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_pair_l _ N k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_pair_r N _ k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_inl _ k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_inr _ k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_fst _ k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_snd _ k)] ⇒ ?

  | [ ⊢ config (fst M) k] ⇒ ?
  | [ ⊢ config (snd M) k] ⇒ ?

  | [ ⊢ config (inl M) k] ⇒ ?
  | [ ⊢ config (inl v) halt] ⇒ ?
  | [ ⊢ config (inl v) (s_app (lam (\y. N)) _ k)] ⇒ ?
  | [ ⊢ config (inl v) (s_pair_l _ N k)] ⇒ ?
  | [ ⊢ config (inl v) (s_pair_r N _ k)] ⇒ ?
  | [ ⊢ config (inl v) (s_inl _ k)] ⇒ ?
  | [ ⊢ config (inl v) (s_inr _ k)] ⇒ ?
  | [ ⊢ config (inl v) (s_cse _ (\x. M) (\y. N) k)] ⇒ ?

  | [ ⊢ config (inr M) k] ⇒ ?
  | [ ⊢ config (inr v) halt] ⇒ ?
  | [ ⊢ config (inr v) (s_app (lam (\y. N)) _ k)] ⇒ ?
  | [ ⊢ config (inr v) (s_pair_l _ N k)] ⇒ ?
  | [ ⊢ config (inr v) (s_pair_r N _ k)] ⇒ ?
  | [ ⊢ config (inr v) (s_inl _ k)] ⇒ ?
  | [ ⊢ config (inr v) (s_inr _ k)] ⇒ ?
  | [ ⊢ config (inr v) (s_cse _ (\x. M) (\y. N) k)] ⇒ ?

  | [ ⊢ config (cse L (\x. M) (\y. N)) k] ⇒ ?

  | [ ⊢ config (throw k M) k'] ⇒ ?

  | [ ⊢ config (letcc (\a. M)) k] ⇒ ?

;




