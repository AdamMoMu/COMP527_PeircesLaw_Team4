% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
  | ¬  : o → o
  | ∀  : (i → o) → o
  | ∃  : (i → o) → o
;


--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B
  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Negation
  | ¬I : ({p:o} cnd A → cnd p)
	 → cnd (¬ A)
	       
  | ¬E : cnd (¬ A) → cnd A
	 → cnd C
	       

  % First Order Logic
  | ∀I : ({a:i} cnd (A a)) 
	 → cnd (∀ (\x. A x))

  | ∀E : {T:i} cnd (∀ A) 
	 → cnd (A T)       

  | ∃I : {T:i} cnd (A T)           
	 → cnd (∃ A)

  | ∃E : cnd (∃ A)
	 → ({a:i} cnd (A a) → cnd C)
	 → cnd C

  % Peirce's Law
  | PL: cnd ((A ⊃ B) ⊃ A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (¬ A))] =
[ ⊢ PL (⊃I \u. 
          (⊥E 
            (⊃E 
              (⊃I \v. 
                (⊃E u (∨Ir v))
              )
              (¬I \p. \w. ⊥E 
                (⊃E u (∨Il w))
              )
            )
          )
        )
  ] 
;



% Alternate Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | nil : tm
  | abort : tm → tm

  % First Order Logic
  | app_f : tm → i → tm
  | lam_f : (i → tm) → tm
  
  | pair_f : tm → i → tm
  | let_val_f : tm → (i -> tm → tm) → tm 

  % Negation
  | abort_n : tm → tm → tm
  | intro_n : (o → tm → tm) → tm

  % Peirces Law proof term
  % call with current continuation: cc
  | cc : tm → tm
;



% Use proof terms
LF pt : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃Ip : ({x : tm} pt x A → pt (M x) B)  → pt (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃Ep : pt M (A ⊃ B) → pt N A → pt (app M N) B

  | ∧Ip : pt M A → pt N B → pt (pair M N) (A ∧ B)
  | ∧Elp : pt M (A ∧ B) → pt (fst M) A
  | ∧Erp : pt M (A ∧ B) → pt (snd M) B

  | ∨Ilp : pt M A → pt (inl M) (A ∨ B)
  | ∨Irp : pt M B → pt (inr M) (A ∨ B)
  | ∨Ep  : pt M (A ∨ B)
        → ({x : tm} pt x A → pt (Nl x) C)
        → ({y : tm} pt y B → pt (Nr y) C)   
        → pt (cse M (\x. Nl x) (\y. Nr y)) C

  | ⊤Ip : pt nil ⊤

  | ⊥E : pt M ⊥ → pt (abort M) C

  % Negation
  | ¬Ip : ({x : tm}{p:o} pt x A → pt (M p x) p)
	 → pt (intro_n (\p. \x. M p x)) (¬ A)
	       
  | ¬Ep : pt M (¬ A) → pt N A
	 → pt (abort_n M N) C
	       
  % First Order Logic
  | ∀Ip : ({a:i} pt (M a) (A a)) 
	 → pt (lam_f (\a. M a)) (∀ (\x. A x))

  | ∀Ep : {T:i} pt M (∀ A) 
	 → pt (app_f M T) (A T)       

  | ∃Ip : {T:i} pt (M) (A T)           
	 → pt (pair_f M T) (∃ A)

  | ∃Ep : pt M (∃ A)
	 → ({a:i}{u:tm} pt u (A a) → pt (N u a) C)
	 → pt (let_val_f M (\a.\u. N u a)) C

  % Peirce's Law 
  | PLp: pt M ((A ⊃ B) ⊃ A) → pt (cc M) A

;

% TODO prove preservation and progress
% Examples:
% https://github.com/Beluga-lang/Beluga/blob/master/examples/mini-ml/tps.bel
% https://github.com/Beluga-lang/Beluga/blob/master/examples/small-step/lam.bel


% Values (not sure what exactly it is yet)
LF value : tm → type =
  | value_nil : value nil
  | value_lam : value (lam (\x. M x))
  | value_intro_n : value (intro_n (\p. \x. M p x))
  | value_lam_f : value (lam_f (\a. M a))
  | value_cse : value (cse M (\x. Nl x) (\y. Nr y))
  | value_let_val_f : value (let_val_f M (\a.\u. N u a))
  ;



% Step (reduction)
LF step : tm → tm → type = 
  % Congruence Rules
  % They done involve any simplifications, they usually only update propositions
  | step_app_l : (step A1 A2) → (step (app A1 B) (app A2 B))
  | step_app_r : (value A) → (step B1 B2) → (step (app A B1) (app A B2))

  % value is used to say A already finished stepping and doesnt need to be stepped anymore
  % This is because we are assumming the "program" runs left to right, so A before B


  % This doesnt work
  % In this context lambda is a function, so it cant be stepped through until the value of x is known
  % So lam is a value instead
  % Beluga checks this automatically, if you uncomment this line it gives and error
  % | step_lam : (step M1 M2) → (step (lam (\x. M1 x)) (lam (\x. M2 x)))

  | step_pair_l : (step A1 A2) → (step (pair A1 B) (pair A2 B))
  | step_pair_r : (value A) → (step B1 B2) → (step (pair A B1) (pair A B2))

  | step_fst : (step A1 A2) → (step (fst A1) (fst A2))
  | step_snd : (step A1 A2) → (step (snd A1) (snd A2))

  | step_inl : (step A1 A2) → (step (inl A1) (inl A2))
  | step_inr : (step A1 A2) → (step (inr A1) (inr A2))

  % For the next case, the functions cant be stepped, but the other term can be

  % Works
  | step_cse : step M1 M2 → step (cse M1 (\x. Nl x) (\y. Nr y)) (cse M2 (\x. Nl x) (\y. Nr y))

  % Correctly Doesnt work , so it also needs a value
  % | step_cse_l : step Nl1 Nl2 → step (cse M (\x. Nl1 x) (\y. Nr y)) (cse M (\x. Nl2 x) (\y. Nr y)) 

  | step_abort : (step A1 A2) → (step (abort A1) (abort A2))

  % First Order Logic
  | step_app_f : (step M1 M2) → (step (app_f M1 T) (app_f M2 T))
  
  | step_pair_f : (step M1 M2) → (step (pair_f M1 T) (pair_f M2 T))

  | step_let_val_f : step M1 M2 → step (let_val_f M1 (\a.\u. N u a)) (let_val_f M2 (\a.\u. N u a))

  % Negation
  | step_abort_n_l : (step A1 A2) → (step (abort_n A1 B) (abort_n A2 B))
  | step_abort_n_r : (value A) → (step B1 B2) → (step (abort_n A B1) (abort_n A B2))

  % Peirces Law proof term
  % call with current continuation: cc
  | step_cc : (step A1 A2) → (step (cc A1) (cc A2))


  % Principal Cases
  % These are standard reduction from local soundness
  %   app (lam (\x. M) N) = [N/x] M 
  % 
  %   fst (A B) = A
  %   snd (A B) = B
  % 
  %   (cse (inl M) (\x. Nl) (\x. Nr)) = Nl M
  %   (cse (inr M) (\x. Nl) (\x. Nr)) = Nr M
  % 
  %   abort_n ((intro_n (\p. \x. M p x))) N = [N/x][C/p]N (C is the proposition)
  %   
  %   app_f (lam_f (\a. M a)) t = [t/a] M
  %   
  %   let_val_f (pair_f M T) (\a.\u. N u a) = [M/u, T/a] N
  %   
  %   cc ?

  | step_app_lam : value N → step (app (lam (\x. M x)) N) (M N)

  
  | step_fst_pair : step (fst (pair M N)) M
  | step_snd_pair : step (snd (pair M N)) N
  
  | step_inl_cse : ?
  | step_inr_cse : ?

  | step_neg : ?

  | step_exist : ?
  
  | step_all : ?

  | step_cc : ?
;





% Preservation





% Progress
