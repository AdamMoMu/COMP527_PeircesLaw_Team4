% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
;


--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B

  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Peirce's Law
  | PL: (cnd (A ⊃ ⊥) → cnd A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (A ⊃ ⊥))] =
[ ⊢ PL (\u. ∨Ir (
          ⊃I (\v.
            ⊃E u (∨Il v)
          )
))
  ] 
;





% Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | taut : tm
  | abort : tm → tm 

  | throw : stack → tm → tm 

  | letcc : (stack → tm) → tm


% Stack 
and stack : type =
  | s_lam : tm → stack → stack % app _ N k
  | s_app : tm → stack → stack % app M _
  
  | s_pair_l : tm → stack → stack
  | s_pair_r : tm → stack → stack
  | s_fst : stack → stack
  | s_snd : stack → stack

  | s_inl : stack → stack
  | s_inr : stack → stack
  | s_cse : (tm → tm) → (tm → tm) → stack → stack

  | s_abort : stack → stack

  | halt : stack

;


% Use proof terms
LF pt_true : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃I : ({x : tm} pt_true x A → pt_true (M x) B)  → pt_true (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃E : pt_true M (A ⊃ B) → pt_true N A → pt_true (app M N) B

  | ∧I : pt_true M A → pt_true N B → pt_true (pair M N) (A ∧ B)
  | ∧El : pt_true M (A ∧ B) → pt_true (fst M) A
  | ∧Er : pt_true M (A ∧ B) → pt_true (snd M) B

  | ∨Il : pt_true M A → pt_true (inl M) (A ∨ B)
  | ∨Ir : pt_true M B → pt_true (inr M) (A ∨ B)
  | ∨E  : pt_true M (A ∨ B)
        → ({x : tm} pt_true x A → pt_true (Nl x) C)
        → ({y : tm} pt_true y B → pt_true (Nr y) C)   
        → pt_true (cse M (\x. Nl x) (\y. Nr y)) C

  | ⊤I : pt_true taut ⊤

  | ⊥E : pt_true M ⊥ → pt_true (abort M) C

  | throw_app : pt_false k A → pt_true M A → pt_true (throw k M) ⊥

  | PL: ({a : stack} pt_false a A → pt_true M A) → pt_true (letcc (\a. M)) A


and pt_false: stack → o → type = 
  | Ax : pt_false halt M
  | ⊥FI : pt_false k M → pt_false (s_abort k) ⊥

  | ⊃FI : pt_true N A → pt_false k B → pt_false (s_lam N k) (A ⊃ B)
  | ⊃FE : pt_true M (A ⊃ B) → pt_false k B → pt_false (s_app M k) A

  | ∧FEl : pt_true N B → pt_false k (A ∧ B) → pt_false (s_pair_l N k) A
  | ∧FEr : pt_true M A → pt_false k (A ∧ B) → pt_false (s_pair_r M k) B

  | ∧FIl : pt_false k A → pt_false (s_fst k) (A ∧ B)
  | ∧FIr : pt_false k B → pt_false (s_snd k) (A ∧ B)

  | ∨FEl : pt_false k (A ∨ B) → pt_false (s_inl k) A
  | ∨FEr : pt_false k (A ∨ B) → pt_false (s_inr k) B

  | ∨FI  :({x : tm} pt_true x A → pt_true M C)
        → ({y : tm} pt_true y B → pt_true N C)   
        → pt_false k C
        → pt_false (s_cse (\x. M) (\y. N) k) (A ∨ B)
;






LF joint : type =
  | config: tm → stack → joint
;


% With both contexts
LF pt_conf : joint → o → type = 
  | joined : pt_true M A → pt_false k A → pt_conf (config M k) A
;


% Values 
LF value : tm → type =
  | value_taut : value taut
  | value_lam : value (lam (\x. M))
  | value_pair : value M → value N → value (pair M N)
  | value_inl : value M → value (inl M)
  | value_inr : value M → value (inr M)
  ;


% Terminal
LF terminal : joint → type =
  | term_taut : terminal (config taut halt)
  | term_lam : terminal (config (lam (\x. M)) halt)
  | term_pair : value M → value N → terminal (config (pair M N) halt)
  | term_inl : value M → terminal (config (inl M) halt)
  | term_inr : value M → terminal (config (inr M) halt)
;


% Small step
LF step : joint → joint → type = 
  | step_abort : (step (config (abort M) k) (config M (s_abort k)))

  | step_throw : (step (config (throw k' M') k) (config M' k'))

  | step_lam : (step (config (app M N) k) (config M (s_lam N k)))

  | step_app : value (lam (\x. M)) → (step (config (lam (\x. M')) (s_lam N k)) (config N (s_app (lam (\x. M')) k)))

  | step_app_lam : value (lam (\x. M)) → value v → (step (config v (s_app (lam (\x. (M' x))) k)) (config (M' v) k))

  | step_pair_l : (step (config (pair M N) k) (config M (s_pair_l N k)))

  | step_pair_r : value v → (step (config v (s_pair_l N k)) (config N (s_pair_r v k)))

  | step_pair_comp : value v → value w → (step (config w (s_pair_r v k)) (config (pair v w) k))

  | step_fst : (step (config (fst M) k) (config M (s_fst k)))
  | step_snd : (step (config (snd M) k) (config M (s_snd k)))

  | step_fst_pair : value v → value w → (step (config (pair v w) (s_fst k)) (config v k))
  | step_snd_pair : value v → value w → (step (config (pair v w) (s_snd k)) (config w k))

  | step_inl : (step (config (inl M) k) (config M (s_inl k)))
  | step_inr : (step (config (inr M) k) (config M (s_inr k)))

  | step_inl_comp : value v → (step (config v (s_inl k)) (config (inl v) k))
  | step_inr_comp : value v → (step (config v (s_inr k)) (config (inr v) k))

  | step_cse : (step (config (cse L (\x. M) (\y. N)) k) (config L (s_cse (\x. M) (\y. N) k)))

  | step_cse_inl : value v → (step (config (inl v) (s_cse (\x. (M x)) (\y. (N y)) k)) (config (M v) k))
  | step_cse_inr : value v → (step (config (inr v) (s_cse (\x. (M x)) (\y. (N y)) k)) (config (N v) k))
  
  | step_let_cc : (step (config (letcc (\a. (M a))) k) (config (M k) k))

;




LF tm_sub: tm → tm → type =
  | sub_app_lam : value N → tm_sub (app (lam (\x. M x)) N) (M N)
  
  | sub_fst_pair : tm_sub (fst (pair M N)) M
  | sub_snd_pair : tm_sub (snd (pair M N)) N
  
  | sub_inl_cse : tm_sub (cse (inl M) (\x. Nl x) (\y. Nr y)) (Nl M)
  | sub_inr_cse : tm_sub (cse (inr M) (\x. Nl x) (\y. Nr y)) (Nr M)

;


rec sub_lemma : [ ⊢ pt_true M P] → [ ⊢ tm_sub M M'] → [ ⊢ pt_true M' P] = 
/ total s (sub_lemma M P M' p s)/
fn p ⇒ fn s ⇒ case s of
  | [ ⊢ sub_app_lam V1] ⇒	
    let [ ⊢ ⊃E (⊃I (\v. \u. D1)) D2] = p in
      [ ⊢ D1[_,D2]]

  | [ ⊢ sub_fst_pair] ⇒	
    let [ ⊢ ∧El (∧I D1 D2)] = p in
      [ ⊢ D1]

  | [ ⊢ sub_snd_pair] ⇒	
    let [ ⊢ ∧Er (∧I D1 D2)] = p in
      [ ⊢ D2]

  | [ ⊢ sub_inl_cse] ⇒	
    let [ ⊢ ∨E (∨Il D1) (\u. \v. D2) (\u. \v. D3)] = p in
      [ ⊢ D2[_,D1]]

  | [ ⊢ sub_inr_cse] ⇒	
    let [ ⊢ ∨E (∨Ir D1) (\u. \v. D2) (\u. \v. D3)] = p in
      [ ⊢ D3[_,D1]]
;



inductive Result : {M : [ ⊢ tm]}{k : [ ⊢ stack]} → ctype =
| Res : {P : [ ⊢ o]} 
      → [ ⊢ pt_conf (config M k) P]
      → Result [ ⊢ M] [ ⊢ k]
;




% Preservation
rec pres :  [ ⊢ pt_conf (config M k) P] → [ ⊢ step (config M k) (config M' k') ] → Result [ ⊢ M'] [ ⊢ k'] = 
/ total s (pres M k P M' k' p s)/
fn p ⇒ fn s ⇒ case s of
  | [ ⊢ step_abort] ⇒	
    let [ ⊢ joined (⊥E D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (⊥FI D2)]
      
  | [ ⊢ step_lam] ⇒	
    let [ ⊢ joined (⊃E D1 D2) (D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (⊃FI D2 D3)]
      
  | [ ⊢ step_app V1] ⇒	
    let [ ⊢ joined D1 (⊃FI D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D2 (⊃FE D1 D3)]
      
  | [ ⊢ step_app_lam V1 V2] ⇒	
    let [ ⊢ joined D1 (⊃FE D2 D3)] = p in 
    let [ ⊢ D4] = (sub_lemma [ ⊢ ⊃E D2 D1] [ ⊢ sub_app_lam V2]) in
      Res [ ⊢ _] [ ⊢ joined D4 D3]
      
  | [ ⊢ step_pair_l] ⇒	
    let [ ⊢ joined (∧I D1 D2) (D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∧FEl D2 D3)]
      
  | [ ⊢ step_pair_r V1] ⇒	
    let [ ⊢ joined D1 (∧FEl D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D2 (∧FEr D1 D3)]
      
  | [ ⊢ step_pair_comp V1 V2] ⇒	
    let [ ⊢ joined D1 (∧FEr D2 D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined (∧I D2 D1) D3]
      
  | [ ⊢ step_fst] ⇒	
    let [ ⊢ joined (∧El D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∧FIl D2)]
      
  | [ ⊢ step_snd] ⇒	
    let [ ⊢ joined (∧Er D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∧FIr D2)]
      
  | [ ⊢ step_fst_pair V1 V2] ⇒	
    let [ ⊢ joined (∧I D1 D2) (∧FIl D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 D3]
      
  | [ ⊢ step_snd_pair V1 V2] ⇒	
    let [ ⊢ joined (∧I D1 D2) (∧FIr D3)] = p in 
      Res [ ⊢ _] [ ⊢ joined D2 D3]
      
  | [ ⊢ step_inl] ⇒	
    let [ ⊢ joined (∨Il D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∨FEl D2)]
      
  | [ ⊢ step_inr] ⇒	
    let [ ⊢ joined (∨Ir D1) (D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∨FEr D2)]
      
  | [ ⊢ step_inl_comp V] ⇒	
    let [ ⊢ joined D1 (∨FEl D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined (∨Il D1) D2]
      
  | [ ⊢ step_inr_comp V] ⇒	
    let [ ⊢ joined D1 (∨FEr D2)] = p in 
      Res [ ⊢ _] [ ⊢ joined (∨Ir D1) D2]
      
  | [ ⊢ step_cse] ⇒	
    let [ ⊢ joined (∨E D1 (\x. \d. D2) (\y. \d. D3)) D4] = p in 
      Res [ ⊢ _] [ ⊢ joined D1 (∨FI (\x. \d. D2) (\y. \d. D3) D4)]
      
  | [ ⊢ step_cse_inl V] ⇒	
    let [ ⊢ joined D1 (∨FI (\x. \d. D2) (\y. \d. D3) D4)] = p in 
    let [ ⊢ D5] = (sub_lemma [ ⊢ (∨E D1 (\x. \d. D2) (\y. \d. D3))] [ ⊢ sub_inl_cse]) in
      Res [ ⊢ _] [ ⊢ joined D5 D4]
      
  | [ ⊢ step_cse_inr V] ⇒	
    let [ ⊢ joined D1 (∨FI (\x. \d. D2) (\y. \d. D3) D4)] = p in 
    let [ ⊢ D5] = (sub_lemma [ ⊢ (∨E D1 (\x. \d. D2) (\y. \d. D3))] [ ⊢ sub_inr_cse]) in
      Res [ ⊢ _] [ ⊢ joined D5 D4]
      
  | [ ⊢ step_throw] ⇒
    let [ ⊢ joined (throw_app D1 D2) D3] = p in 
      Res [ ⊢ _] [ ⊢ joined D2 D1]
      
  | [ ⊢ step_let_cc] ⇒
    let [ ⊢ joined (PL (\a. \d. D1)) D2] = p in 
      Res [ ⊢ _] [ ⊢ joined D1[_,D2] D2]
;









inductive Result_Prog : ctype =
| Res_Step : {C : [ ⊢ joint]} 
      → {C' : [ ⊢ joint]} 
      → [ ⊢ step C C']
      → Result_Prog 

| Res_Term : {C : [ ⊢ joint]} 
      → [ ⊢ terminal C]
      → Result_Prog 
;


% Progress 
rec prog : [ ⊢ joint] → Result_Prog = 
fn c ⇒ case c of

  | [ ⊢ config taut halt] ⇒ Res_Term [ ⊢ config taut halt] [ ⊢ term_taut]

  | [ ⊢ config (abort M) k] ⇒ Res_Step [ ⊢ config (abort M) k] [ ⊢ (config M (s_abort k))] [ ⊢ step_abort]


  %396 |  | [ ⊢ config (lam (\x. M)) halt] ⇒ Res_Term [ ⊢ config (lam (\x. M)) halt] [ ⊢ term_lam]                                                           ^^^^^^^^  
  % Error: Ill-typed expression.
  %        Expected type:
  %          term (config (lam (\x. M)) halt)
  %        Actual type:
  %          term (config (lam (\x. ?M_7334[^0][])) halt)

  | [ ⊢ config (lam (\x. M)) halt] ⇒ Res_Term [ ⊢ config (lam (\x. M)) halt] [ ⊢ term_lam]

  % Error
  % 402 |  | [ ⊢ config (lam (\x. M)) (s_lam N k)] ⇒ Res_Step [ ⊢ config (lam (\x. M)) (s_lam N k)] [ ⊢ (config N (s_app (lam (\x. M)) k))] [ ⊢ (step_app value_lam)]
  %                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^  
  % Error: Ill-typed expression.
  %        Expected type:
  %          step
  %            (config (lam (\x. M)) (s_lam N k))
  %            (config N (s_app (lam (\x. M)) k))
  %        Actual type:
  %          step
  %            (config (lam (\x. ?M'_7338[^0][]))
  %            (s_lam ?N_7339[^0][] ?k_7340[^0][]))
  %            (config ?N_7339[^0][]
  %            (s_app (lam (\x. ?M'_7338[^0][])) ?k_7340[^0][]))
  
  | [ ⊢ config (lam (\x. M)) (s_lam N k)] ⇒ Res_Step [ ⊢ config (lam (\x. M)) (s_lam N k)] 
                                                      [ ⊢ (config N (s_app (lam (\x. M)) k))] 
                                                      [ ⊢ (step_app value_lam)]
  
  
  | [ ⊢ config (lam (\x. M)) (s_app (lam (\y. N)) k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_pair_l N k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_pair_r N k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_inl k)] ⇒ ?
  | [ ⊢ config (lam (\x. M)) (s_inr k)] ⇒ ?

  | [ ⊢ config (app M N) k] ⇒ ?

  | [ ⊢ config (pair M N) k] ⇒ ?
  | [ ⊢ config (pair v w) halt] ⇒ ?
  | [ ⊢ config (pair v w) (s_app (lam (\y. N)) k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_pair_l N k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_pair_r N k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_inl k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_inr k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_fst k)] ⇒ ?
  | [ ⊢ config (pair v w) (s_snd k)] ⇒ ?

  | [ ⊢ config (fst M) k] ⇒ ?
  | [ ⊢ config (snd M) k] ⇒ ?

  | [ ⊢ config (inl M) k] ⇒ ?
  | [ ⊢ config (inl v) halt] ⇒ ?
  | [ ⊢ config (inl v) (s_app (lam (\y. N)) k)] ⇒ ?
  | [ ⊢ config (inl v) (s_pair_l N k)] ⇒ ?
  | [ ⊢ config (inl v) (s_pair_r N k)] ⇒ ?
  | [ ⊢ config (inl v) (s_inl k)] ⇒ ?
  | [ ⊢ config (inl v) (s_inr k)] ⇒ ?
  | [ ⊢ config (inl v) (s_cse (\x. M) (\y. N) k)] ⇒ ?

  | [ ⊢ config (inr M) k] ⇒ ?
  | [ ⊢ config (inr v) halt] ⇒ ?
  | [ ⊢ config (inr v) (s_app (lam (\y. N)) k)] ⇒ ?
  | [ ⊢ config (inr v) (s_pair_l N k)] ⇒ ?
  | [ ⊢ config (inr v) (s_pair_r N k)] ⇒ ?
  | [ ⊢ config (inr v) (s_inl k)] ⇒ ?
  | [ ⊢ config (inr v) (s_inr k)] ⇒ ?
  | [ ⊢ config (inr v) (s_cse (\x. M) (\y. N) k)] ⇒ ?

  | [ ⊢ config (cse L (\x. M) (\y. N)) k] ⇒ ?

  | [ ⊢ config (throw k M) k'] ⇒ ?

  | [ ⊢ config (letcc (\a. M)) k] ⇒ ?

;




