% Classical logic using Peirce's law

i : type.

LF o : type =  % formulas
  | ⊃ : o → o → o
  | ⊤ : o
  | ⊥ : o
  | ∧   : o → o → o
  | ∨   : o → o → o
  | ¬  : o → o
  | ∀  : (i → o) → o
  | ∃  : (i → o) → o
;


--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.


% Classical Natural Deduction Rules
LF cnd : o → type = 
  % Natural Deduction
  | ⊃I : (cnd A → cnd B)
	 → cnd (A ⊃ B)
  | ⊃E : cnd (A ⊃ B) → cnd A
	 → cnd B
  | ∧I : cnd A → cnd B → cnd (A ∧ B)
  | ∧El : cnd (A ∧ B) → cnd A
  | ∧Er : cnd (A ∧ B) → cnd B
  | ∨Il : cnd A → cnd (A ∨ B)
  | ∨Ir : cnd B → cnd (A ∨ B)
  | ∨E  : cnd (A ∨ B)
        → (cnd A → cnd C)
        → (cnd B → cnd C)        
        → cnd C

  | ⊤I : cnd ⊤
  | ⊥E : cnd ⊥ → cnd C

  % Negation
  | ¬I : ({p:o} cnd A → cnd p)
	 → cnd (¬ A)
	       
  | ¬E : cnd (¬ A) → cnd A
	 → cnd C
	       

  % First Order Logic
  | ∀I : ({a:i} cnd (A a)) 
	 → cnd (∀ (\x. A x))

  | ∀E : {T:i} cnd (∀ A) 
	 → cnd (A T)       

  | ∃I : {T:i} cnd (A T)           
	 → cnd (∃ A)

  | ∃E : cnd (∃ A)
	 → ({a:i} cnd (A a) → cnd C)
	 → cnd C

  % Peirce's Law
  | PL: cnd ((A ⊃ B) ⊃ A) → cnd A

;



% Proof of Law of excluded middle
rec exm : [ ⊢ cnd (A ∨ (¬ A))] =
[ ⊢ PL (⊃I \u. 
          (⊥E 
            (⊃E 
              (⊃I \v. 
                (⊃E u (∨Ir v))
              )
              (¬I \p. \w. ⊥E 
                (⊃E u (∨Il w))
              )
            )
          )
        )
  ] 
;



% Alternate Proof Terms
LF tm : type =
  | app : tm → tm → tm
  | lam : (tm → tm) → tm
  
  | pair : tm → tm → tm
  | fst : tm → tm
  | snd : tm → tm

  | inl : tm → tm
  | inr : tm → tm
  | cse : tm → (tm → tm) → (tm → tm) → tm

  | nil : tm
  | abort : tm → tm

  % First Order Logic
  | app_f : tm → i → tm
  | lam_f : (i → tm) → tm
  
  | pair_f : tm → i → tm
  | let_val_f : tm → (i -> tm → tm) → tm 

  % Negation
  | abort_n : tm → tm → tm
  | v : (o → tm → tm) → tm

  % Peirces Law proof term
  % call with current continuation: cc
  | cc : tm → tm
;



% Use proof terms
LF pt : tm → o → type = 
  % Implication Intro x:A, M:B → lam x. M : A⊃B
  % Here we have (M x):B. It is saying M is the function body,and x is "applied" to it
  % so to extract the function body, lam M : A⊃B
  | ⊃Ip : ({x : tm} pt x A → pt (M x) B)  → pt (lam (\x. M x)) (A ⊃ B)

  % Implication Elim M:A⊃B, N:A → M N: B
  | ⊃Ep : pt M (A ⊃ B) → pt N A → pt (app M N) B

  | ∧Ip : pt M A → pt N B → pt (pair M N) (A ∧ B)
  | ∧Elp : pt M (A ∧ B) → pt (fst M) A
  | ∧Erp : pt M (A ∧ B) → pt (snd M) B

  | ∨Ilp : pt M A → pt (inl M) (A ∨ B)
  | ∨Irp : pt M B → pt (inr M) (A ∨ B)
  | ∨Ep  : pt M (A ∨ B)
        → ({x : tm} pt x A → pt (Nl x) C)
        → ({y : tm} pt y B → pt (Nr y) C)   
        → pt (cse M (\x. Nl x) (\y. Nl y)) C

  | ⊤Ip : pt nil ⊤

  | ⊥E : pt M ⊥ → pt (abort M) C

  % Negation
  | ¬Ip : ({x : tm}{p:o} pt x A → pt (M p x) p)
	 → pt (v M) (¬ A)
	       
  | ¬Ep : pt M (¬ A) → pt N A
	 → pt (abort_n M N) C
	       
  % First Order Logic
  | ∀Ip : ({a:i} pt (M a) (A a)) 
	 → pt (lam_f (\a. M a)) (∀ (\x. A x))

  | ∀Ep : {T:i} pt M (∀ A) 
	 → pt (app_f M T) (A T)       

  | ∃Ip : {T:i} pt (M) (A T)           
	 → pt (pair_f M T) (∃ A)

  | ∃Ep : pt M (∃ A)
	 → ({a:i}{u:tm} pt u (A a) → pt (N u a) C)
	 → pt (let_val_f M (\a.\u. N u a)) C

  % Peirce's Law 
  | PLp: pt M ((A ⊃ B) ⊃ A) → pt (cc M) A

;

% TODO prove preservation and progress
% Examples:
% https://github.com/Beluga-lang/Beluga/blob/master/examples/mini-ml/tps.bel
% https://github.com/Beluga-lang/Beluga/blob/master/examples/small-step/lam.bel

